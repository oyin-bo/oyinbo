# REPL Log Format Improvements (1.5.2-repl-tidy)

## Overview

This document outlines improvements to daebug REPL log formatting to enhance navigation, readability, and cognitive support for both human debuggers and AI agents. The new format uses Markdown heading hierarchy strategically to enable outline navigation, code folding, and clearer separation of concerns.

## Current State

The current daebug REPL log format uses blockquotes (`>`) for all headers:
- Agent requests: `> **agent** to page at HH:MM:SS`
- Replies: `> **page** to agent at HH:MM:SS (duration)`
- Background events: `> **page** background at HH:MM:SS`

This format has limitations:
- No native Markdown outline navigation
- No expand/collapse support in editors
- Difficult to scan long debugging sessions
- No clear visual hierarchy
- Limited structure for adding explanatory notes

## Proposed Format

### File Structure

```
# <Descriptive Title of This Debugging Session>

This file contains a live debugging session. It allows this and that and it will execute your commands like this and that (actual explanation to be provided).

## Short Guide

- **Plain-text notes:** Add context before each request explaining what you're trying to do and why.
- **Chain of thought:** Describe your hypothesis, what you're checking, and observations at any point of your work.
- **Section headers:** Use level-2 headers (`##`) to mark substantial debugging turns. Add a short note on your plan below the header.
- **Cleanup:** As sessions grow long, replace old irrelevant chunks between level-2 section headers with 1-paragraph summaries.
- **Simple requests:** Start with basic expressions like `1+1`, `Object.keys(window)` to verify connectivity
- **Test runs:** Use `(await import('node:test')).run();` to execute tests and review output

---

### 🗣️agent to 16-iris-2234-06 at 10:37:00

Verifying page is alive and responding.

\`\`\`JS
1 + 1
\`\`\`

#### 👍16-iris-2234-06 to agent at 11:20:37 (123ms)

\`\`\`JSON
2
\`\`\`

### 🗣️agent to 16-iris-2234-06 at 10:37:05

Let's check what warnings were logged during startup

\`\`\`JS
console.log('Warnings found:', window.__warnings?.length || 0)
\`\`\`

#### 👍16-iris-2234-06 to agent at 11:20:39 (31ms)

\`\`\`JSON
"Warnings found: 3"
\`\`\`

##### 🆘 console.warn
\`\`\`Text console.warn
at clientMainFunction (http://localhost:8680/:330:15) 10:37:01.500
Network timeout: failed to fetch config
\`\`\`
##### 🔢 console.info
\`\`\`Text console.info
at setupModule (http://localhost:8680/:42:10) 10:37:01.520
Initialization complete
\`\`\`

### 🗣️agent to 16-iris-2234-06 at 10:37:10

Running test suite to identify failures

\`\`\`JS
(await import('node:test')).run()
\`\`\`

#### 🚫16-iris-2234-06 to agent at 11:20:37
executing (0s)

\`\`\`Text
AssertionError: expected false to be true
  at Context.test (http://localhost:8680/:125:20)
\`\`\`

##### 🚫window.onerror
\`\`\` Error
AssertionError: expected false to be true
  at Context.test (/tests/main.test.js:125:20)
    at processTicksAndPromises (internal/timers:internal:promisses.js:308:27)
10:37:10.850
\`\`\`

```

### Formatting Rules

#### 1. File Header (Level-1: `#`)

Every REPL log **must** have a level-1 heading describing the session:

```markdown
# Testing Widget Component Interaction
```

**Template functions:** The file header and guide section are templatised in `js/repl.template.js` as:
- `formatFileHeader(title)` — generates the level-1 header line
- `formatSessionGuide()` — generates the full "Short Guide" section with level-2 header
- `ensureFileHeader(lines, defaultTitle)` — verifies/inserts header and guide on every write operation

**Header verification logic** (on every write operation):
1. Read file into lines array
2. Call `ensureFileHeader(lines, defaultTitle)` which:
   - **Scans first 20 lines** for pattern `^# ` (level-1 header)
   - If level-1 header found: **return lines unchanged** (preserves user customization)
   - If level-1 header NOT found:
     - Generate `formatFileHeader(defaultTitle)` 
     - Generate `formatSessionGuide()`
     - Prepend both to lines array (before any existing content)
     - Return modified lines
3. Proceed with normal reply/event writing logic using updated lines

**Rationale for verification-on-every-write:**
- Guards against partially-written files or user edits that remove header
- Ensures all REPL logs remain self-documenting and readable
- Simple idempotent operation: if header exists, no change; if missing, add once
- Cost is negligible: regex scan of first 20 lines during file write

This ensures new logs (even if user-created) and logs after cleanup have proper documentation.

#### 2. Session Guide (Informational Section)

Immediately following the level-1 header, include:
- A broad description what daebug REPL logs are for.
- A level-2 header denoting a guide (so it can be collapsed if it bores the user)
- 1-2 paragraphs explaining REPL usage with tips, tricks and best practices.

#### 3. Debugging Turns (Level-2: `##`)

When starting a new substantial debugging turn, the agent is encouraged to add a level-2 header, but the level-3 header is not mandatory and the only thing necessary is a JS fenced code block.

For example, this is what an agent may add below the footer doing a REPL request:

```markdown
## Investigating Network Failures

\`\`\`JS
// code here
\`\`\`

```

Any content above and below the JS fenced code block will be retained when the REPL is queued for execution, so level-2 header will appear in the output nicely.

Benefits:
- Clear outline navigation in VS Code and other editors
- Allows users to collapse old turns
- Enables retrospective summary: replace content between headers with single paragraph

#### 4. REPL Request (Level-3: `###`)

Formatting generated when agent requests REPL code execution:

```markdown
### 🗣️agent-name to page-name at HH:MM:SS

Any preceding text that agent added above the code block, such as explaining intent.

\`\`\`JS
code here
\`\`\`

Any text that agent added below code block.
```


**Components:**
- Level-3 heading with 🗣️ emoji
- Bold agent name and target page
- Timestamp in `HH:MM:SS` format
- Above/below, and JS code block preserved as is, including any spacing around it

**Rationale:**
- Level-3 enables outline navigation beneath level-2 sections
- 🗣️ emoji provides quick visual scanning
- Encouraging the agents to add plain text note is CRITICAL for remembering and recalling debugging intent when reviewing sessions.

#### 5. REPL Reply (Level-4: `####`)

Format for page/server responding to request:

**Successful response:**
```markdown
#### 👍16-iris-2234-06 to agent at 11:20:37
executing (0s)

\`\`\`JSON
{ "result": 123 }
\`\`\`
```

**Failed response:**
```markdown
#### 🚫16-iris-2234-06 to agent at 11:20:37
executing (0s)

\`\`\`Error
TypeError: Cannot read property 'x' of undefined
\`\`\`
```

**Components:**
- Level-4 heading with emoji (👍 for success, 🚫 for failure)
- Retain the main header formatting from the existing implementation
- Result in fenced code block with appropriate language identifier (retain the current behavior).

**Rationale:**
- Level-4 sits beneath level-3 requests for clear hierarchy
- Emoji enables quick success/failure scanning
- Otherwise the current format is compact and neat.

#### 6. Background Events (Level-5: `#####`)

Format for console logs, errors, and side effects captured during or after request:

**Error:**
```markdown
##### 🚫window.error
\`\`\`Error
TypeError: Cannot read property 'x' of undefined
  at Function (http://localhost:8680/:125:20)
10:37:10.850
\`\`\`
```

**Console output**
```markdown
##### 🆘console.warn
\`\`\`Text console.warn
at setupModule (http://localhost:8680/:42:10) 10:37:01.500
Network timeout: failed to load config
\`\`\`
##### ☑️console.log
\`\`\`Text console.log
Value at step X: 42
\`\`\`
##### ℹ️console.info
\`\`\`Text console.info
at setupModule (http://localhost:8680/:42:10) 10:37:01.520
Initialization step 5 complete
\`\`\`
##### 🔢console.debug
\`\`\`Text console.info
at setupModule (http://localhost:8680/:42:10) 10:37:01.520
Initialization step 5 complete
\`\`\`
```


**Components:**
- Level-5 heading with emoji indicating event type
- Event metadata (caller, timestamp if available)
- Content in fenced block

**Emoji Reference:**
| Event Type | Emoji | Meaning |
|---|---|---|
| Uncaught error | 🚫 | Failure/Error |
| console.error | 🆘 | Distress signal |
| console.warn | 🆘 | Distress signal |
| console.log | ☑️ | Generic log, success |
| console.info | ℹ️ | Informational |
| All others | 🔢 | Numeric/informational |

## Implementation Impact

### Template Changes Required

File: `js/repl.template.js`

New functions to add:

1. **`formatFileHeader(title)`**
   - Returns: `# ${title}`
   - Example: `# Testing Widget Component Interaction`

2. **`formatSessionGuide()`**
   - Returns: Multi-line string with `## Short Guide` header and bullet-point guidelines
   - See current "Proposed Format" section for full content
   - This is a constant template, can be a simple string constant

3. **`ensureFileHeader(lines, defaultTitle)`**
   - **Parameter:** lines array (from file split by `\n`), defaultTitle string
   - **Returns:** Modified lines array with header/guide prepended if missing
   - **Logic:**
     ```
     - Scan lines[0..19] (first 20 lines) for /^# /
     - If found at any position: return lines unchanged
     - If NOT found: 
         * Create headerLine = formatFileHeader(defaultTitle)
         * Create guideLines = formatSessionGuide().split('\n')
         * Create separator = "---"
         * Return [headerLine, '', ...guideLines, separator, '', ...lines]
     ```
   - **Idempotent:** Calling multiple times produces same output

Update existing functions:

4. **`formatAgentHeader(agent, target, ts)`**
   - Change from: `> **${agent}** to ${target} at ${clockFmt(ts)}`
   - Change to: `### 🗣️${agent} to ${target} at ${clockFmt(ts)}`

5. **`formatReplyHeader(page, agent, ts, dur, err)`**
   - Change from: `> **${page}** to ${agent} at ${clockFmt(ts)}${err ? ' (**ERROR**)' : ''} (${durationFmt(dur)})`
   - Change to: `#### ${err ? '🚫' : '👍'}${page} to ${agent} at ${clockFmt(ts)}${err ? '' : ''} (${durationFmt(dur)})`

6. **`formatBackgroundEvent(event)`** (existing function — verify and update)
   - Wrapper each event with appropriate level-5 header
   - Select emoji based on event type (`error` → 🚫, `.error`/`.warn` → 🆘, others → ...)
   - Return: `##### ${emoji}${eventLabel}\n\n${content}`

### Writer Module Changes

File: `js/writer.js`

1. **Update `writeDiagnostic(file, message)`**
   - Before writing any content: read existing file (or use empty array if new)
   - Call `ensureFileHeader(lines, 'System Diagnostic')`
   - Use result as base for diagnostic output
   - Update diagnostic message formatting to use level-3 headers (not blockquotes)

2. **Update `writeReply(job, result)`**
   - Before writing: read file and call `ensureFileHeader(lines, job.page.name + ' Session')`
   - Use returned lines as source for all subsequent parsing/injection logic
   - Call updated `formatReplyHeader()` which now returns level-4 header
   - Background events wrapped with level-5 headers by `formatBackgroundEvent()`

3. **Update `writeExecuting(job)`** (if present)
   - Same header-ensure pattern as `writeReply()`

4. **New function: `writeBackgroundEvents(file, events, timestamp)` — if not present**
   - Ensure file header exists before appending background events
   - Format background events with level-5 headers

### Parser Changes

File: `js/parser.js` (via `js/repl.template.js` exports)

**No changes required to parser logic.** The parser delegates to template functions via `parseRequest()`:

- Request detection continues to look for:
  - First complete fenced code block after header (blockquote or heading-based, no regex change needed)
  - Fenced blocks still marked with ``` delimiters (unchanged)
  
- Parser gracefully handles **mixed old and new format** within same file:
  - Looks for complete fenced blocks without strict header matching
  - Can parse "new format" requests (with level-3 headers) alongside "old format" (with blockquotes)
  - Timestamp extraction works with both formats
  
- No scanning of new level-1, level-2, or level-5 headers needed for request detection
  - These are purely for display/navigation in editor
  - Executable content remains: fenced code blocks

**Verification operation in `writeReply()` / `writeExecuting()`:**
- These functions in `writer.js` call `ensureFileHeader()` before manipulating lines
- This is where header structure is applied, NOT in parser
- Parser remains format-agnostic for robustness

## Format Transition Strategy

**Old Format:** Blockquote headers with no navigation
```
> **agent** to page at HH:MM:SS
> **page** to agent at HH:MM:SS (duration)
```

**New Format:** Heading-based hierarchy with outline navigation
```
### 🗣️agent to page at HH:MM:SS
#### 👍page to agent at HH:MM:SS (duration)
```

**Transition approach:**
- **Parser:** No changes. Continues to accept both formats. Agnostic to header style; locates fenced blocks by delimiter ```` ``` ````.
- **Writer:** Always produces NEW format via `formatAgentHeader()`, `formatReplyHeader()`, etc.
- **Existing files:** On next write operation, `ensureFileHeader()` adds level-1 header + guide if missing. Old blockquote headers remain but new responses use heading format, creating **mixed-format files during transition**.
- **Gradual migration:** Over time, as users edit and re-run code, files naturally become fully new-format. No bulk migration tool needed.
- **Consistency:** Within a single file, mix of old and new formats is acceptable and parseable. No backward-compatibility breakage.

**No breaking change:** Existing REPL logs continue to function during and after this transition.

## Risk Analysis

### **1. File Header Verification Failures**

**Risk:** Corrupted or missing header detection on files that are being simultaneously edited.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Server writes file, user edits simultaneously, header check happens between operations, causing duplicate headers | Low | Medium | `ensureFileHeader()` is idempotent and scan-based (not mutation). Multiple calls produce identical output. Write must be atomic: read + ensure + write in single fs.writeFileSync(). |
| File exists but is empty or truncated during read; header scan fails | Low | Low | Scan first 20 lines using safe array bounds. If file is truncated mid-header, no level-1 found → header added. On next operation, will be present. No data loss. |
| User manually deletes level-1 header after every server write; cycle repeats | Low | Low | Idempotent by design. Each write re-adds header in same location. No escalating corruption. User can disable auto-header if needed (not in scope of this doc). |

**Residual risk:** Negligible. Mitigation is simple, atomic, and idempotent.

---

### **2. Parser Robustness During Mixed-Format Transition**

**Risk:** Files contain both old (blockquote) and new (heading) formats; parser becomes confused or rejects valid code.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Parser looks for old format header, misses new format heading with code, fails to extract request | Medium (during transition) | High | Parser searches for complete fenced code blocks by delimiter (``` ``` ```), NOT by header format. Agnostic to header style. Both formats contain same code block delimiters. No rejection logic. |
| Agent adds level-2 header manually; parser interprets it as request boundary or instruction | Low | Medium | Parser ignores level-2/3/4/5 headers entirely. Scans for fenced blocks only. Manual headers are treated as plain text (preserved, not executed). |
| Background events (level-5 headers with emojis) are somehow parsed as executable code | Very Low | Low | Level-5 events appear AFTER the fenced code result block. Parser looks for code blocks AFTER header, not after result. Clear boundary. |

**Residual risk:** Low. Parser design is deliberately format-agnostic for this reason.

---

### **3. Session Cleanup and Manual Summarization**

**Risk:** Users manually replace old sections with summaries; file structure becomes unparseable or summaries contain code-like content.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| User adds summary text between level-2 headers that contains fenced code block (example code in summary); parser executes it on next operation | Low | Medium | Parser uses sequential scanning: first complete fenced block after agent header. If summary text contains fenced block, it appears BEFORE next request header. Parser will skip it (no agent header directly above). Only new requests with header + code block are dispatched. Test case needed. |
| User deletes entire section including level-2 header; disrupts outline navigation and confuses LLM reading the file | Medium | Low | Outline navigation still works: remaining headers provide structure. LLM can still read and understand file semantically. Not a functional failure, only user experience degradation. |
| User replaces 100-line section with 1-line summary; loses important debugging history | High | Medium | This is intentional behavior per design. Users are encouraged to clean up logs. Trade-off: manageable file size vs. complete history. Mitigation: version control (git) preserves deleted sections. Users should commit before cleanup. |

**Residual risk:** Medium. User action is unpredictable. Recommend:
- Add comment in `## Short Guide` encouraging version control before cleanup
- Add test case: parser must ignore fenced blocks in plain-text summary sections
- Document: cleanup is manual responsibility, not automatic

---

### **4. Emoji Reliability and Internationalization**

**Risk:** Emojis render differently across platforms or get corrupted in encoding.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Emoji render as colored squares or mojibake in some terminals/editors | Medium | Low | Emojis are for visual scanning by humans, NOT parsed by system. Parser looks at heading level (`#####`) and event type (`console.warn`, etc.), not emoji. If emoji corrupts, parsing still works. |
| File encoding changes (UTF-8 → ASCII); emoji lost on re-encode | Low | Medium | Store emoji in source code (`.js` files), not user input. Emoji are written by system via `formatBackgroundEvent()`, not parsed from user input. Encoding is UTF-8 throughout. No conversion needed. |
| Non-English terminal; emoji meanings lost or misunderstood by non-English-speaking users | Low | Low | Emoji are supplementary. Full event information is in heading text and fenced block. `🚫` = error, but heading also says `##### 🚫window.onerror` with full context. Not a blocking issue. |

**Residual risk:** Very Low. Emojis are redundant indicators, not critical to function.

---

### **5. Header Insertion and Merge Conflicts**

**Risk:** Multiple agents write to same file concurrently; header insertion logic causes merge conflicts in version control or file corruption.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Agent 1 and Agent 2 both write to same file; Agent 1 calls `ensureFileHeader()`, Agent 2 calls it simultaneously; both prepend header, creating duplicate header on read | Low (server is single-threaded; jobs are queued) | Medium | Server processes jobs sequentially via `watcher` → `parser` → `job.js` → `writer`. No concurrent writes. Each write is atomic `writeFileSync()`. Header check happens within single write operation. No interleaving. |
| Git merge conflict when two branches both add headers with different titles | Low | Low | Conflict is in file header only. User resolves by choosing one title or combining both in markdown. No data loss; only title edit. Expected merge resolution. |
| File is locked by one process; another process tries to write header; file I/O error | Very Low | Medium | Node.js `writeFileSync()` is atomic on most file systems. If lock occurs, exception bubbles up; job fails, user is notified. Retry logic in `watcher.js` handles transient failures. |

**Residual risk:** Very Low. Server architecture and file I/O are designed to be safe.

---

### **6. Performance and File Size Growth**

**Risk:** Repeated `ensureFileHeader()` scans slow down every write; files grow without cleanup, become unmanageable.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Scanning first 20 lines on every write causes measurable latency | Very Low | Low | Regex scan of 20 lines is <1ms. `writeFileSync()` I/O is dominant cost (1-5ms). Header scan is negligible overhead. Not a performance issue. |
| Files grow unbounded; 1000+ turns accumulate; editor becomes slow | Medium (over long sessions) | Medium | Design is intentional: users are expected to perform cleanup between level-2 headers. `## Short Guide` encourages this. No automatic truncation in scope. Mitigation: educate users; version control preserves history if needed. |
| Large files are slow to read into memory | Low | Low | Session files are append-only logs, not databases. Typical session: 50-200 KB. Node.js handles this easily. Once-per-write read is acceptable. |

**Residual risk:** Low. Mostly a user education and process issue, not a technical failure.

---

### **7. Timestamp Accuracy and Timezone Ambiguity**

**Risk:** `clockFmt()` uses local time (HH:MM:SS); timestamps are ambiguous across timezones or after DST changes.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| User in one timezone shares REPL log with user in another; timestamps are meaningless | Medium | Low | Timestamps are local to the machine running the server. This is documented in `1-jsrepl.md`. Recommendation: include timezone in guide if needed, or use ISO 8601 with Z (future improvement). For now, timestamps are relative to user's local time; acceptable for personal debugging sessions. |
| DST change occurs during long debugging session; times jump backwards | Low | Low | Times are based on `Date.now()` system clock. If system adjusts for DST, times will reflect that. Acceptable for human debugging; not a critical failure. |
| User relies on timestamps for performance profiling | Low | Low | Timestamps are low-precision (per-second). Not suitable for profiling. Durations (in reply headers) are millisecond-precise. Recommendation in guide: use durations, not timestamps, for performance analysis. |

**Residual risk:** Low. Limitation is documented; users should not rely on absolute timestamps for cross-timezone collaboration without explicit agreement.

---

### **8. Background Event Truncation and Loss**

**Risk:** If >10 background events accumulate, some are truncated with ellipsis; information is lost.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| User doesn't notice ellipsis marker and assumes all events are present | Medium | Medium | Ellipsis marker is explicit: `... (N more background events omitted) ...`. Placed visually in output. Recommendation: bold it in generated output to make it more visible. Test case: verify ellipsis appears in typical 50-event scenario. |
| Important error is hidden in the 10+ events that are truncated | Medium | High | Current design: first 2 events + last 8 events shown. Rationale: early events show startup; late events show final failure. Middle events might be duplicate warnings. Acceptable heuristic for most debugging. Better solution (future): full event list via separate REPL command, or configurable threshold. |
| User script that searches file text for specific error can't find it because it was truncated and omitted | Low | Medium | Recommendation: test tools that parse REPL logs should be aware of truncation. Document this limitation in any tool that extracts event information from logs. For now, tool limitation is acceptable; human can increase event threshold if needed (config constant in writer.js). |

**Residual risk:** Medium. Mitigation: improve UI visibility of truncation marker; document limitation; provide override mechanism.

---

### **9. Emoji-Based Header Parsing (Edge Case)**

**Risk:** If `formatReplyHeader()` is called in wrong order or `formatBackgroundEvent()` fails, emoji might be missing or mismatched, breaking visual scanning.

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Bug in emoji selection logic; wrong emoji for event type | Low | Low | Emoji selection is hardcoded switch statement. Impossible emoji mismatch if code is correct. Code review during implementation catches logic errors. Test case: verify each event type produces correct emoji. |
| Emoji embedded in heading but heading level is wrong (e.g., `#### 🚫` instead of `##### 🚫`); parser ignores it | Low | Low | Emoji is cosmetic; heading level matters. If level is wrong, outline navigation breaks but parsing continues (format-agnostic). Test case: verify heading levels match schema (L-3 for requests, L-4 for replies, L-5 for events). |
| Unicode normalization in file encoding causes emoji to change; `👍` becomes `U+1F44B` code point in some editors | Very Low | Very Low | All processing is UTF-8. Emoji are stored as UTF-8 bytes in file. Most editors normalize to same representation. Acceptible; outline navigation and parsing unaffected. |

**Residual risk:** Very Low. Mitigation: comprehensive unit tests for all formatting functions.

---

### **Summary of Mitigations by Priority**

| Priority | Action | Owner | Timeline |
|---|---|---|---|
| 🔴 Critical | Implement atomic `ensureFileHeader()` function with idempotent logic | Developer (js/repl.template.js) | Implementation phase |
| 🔴 Critical | Verify parser is truly format-agnostic; add test case with mixed old/new format in single file | Developer (js/parser.test.js) | Testing phase |
| 🔴 Critical | Add unit test: fenced block in summary text is NOT executed | Developer (js/parser.test.js) | Testing phase |
| 🟡 Important | Add comment in `## Short Guide` encouraging version control before cleanup | Documentation | Before rollout |
| 🟡 Important | Improve UI visibility of event truncation ellipsis marker (bold or highlight) | Developer (js/repl.template.js) | Implementation phase |
| 🟡 Important | Document limitation: timestamps are local time, not timezone-aware | Documentation | Before rollout |
| 🟢 Nice-to-have | Add configurable event truncation threshold in `writer.js` constants | Developer (js/writer.js) | Post-rollout |
| 🟢 Nice-to-have | Add separate REPL command to retrieve full (untruncated) event list for a given job | Developer (new feature) | Post-rollout |

---

## Critical Features Summary

| Feature | Impact | Priority |
|---|---|---|
| Outline navigation (H2/H3/H4/H5) | Enables quick scanning of long sessions | 🔴 CRITICAL |
| Plain-English notes | Retroactive understanding of debugging intent | 🔴 CRITICAL |
| File header + guide | Self-documenting logs (no external docs needed) | 🔴 CRITICAL |
| Emoji indicators | Visual scanning for success/failure/issues | 🟡 Important |
| Chain-of-thought tracking | Retrospective session review | 🟡 Important |
| Section cleanup strategy | Manages log growth and context pollution | 🟡 Important |


## Rollout Plan

### Step 1: Template Functions (js/repl.template.js)

1. Add `formatFileHeader(title)` — generates level-1 header
2. Add `formatSessionGuide()` — generates "Short Guide" section template
3. Add `ensureFileHeader(lines, defaultTitle)` — idempotent header verification
4. Update `formatAgentHeader()` — use level-3 with emoji (### 🗣️)
5. Update `formatReplyHeader()` — use level-4 with emoji (#### 👍/🚫)
6. Verify `formatBackgroundEvent()` — use level-5 with emoji (##### 🚫/🆘/etc.)
7. Update `formatFooter()` if needed (verify still works with new format)

### Step 2: Writer Module (js/writer.js)

1. Update `writeDiagnostic()` — call `ensureFileHeader()` before writing
2. Update `writeReply()` — call `ensureFileHeader()` before any manipulation
3. Update `writeExecuting()` (if exists) — same pattern
4. Verify `writeBackgroundEvents()` — ensure header exists before appending

### Step 3: Parser Verification (js/parser.js, js/repl.template.js)

1. Verify `parseRequest()` remains format-agnostic (no changes needed)
2. Confirm parser handles mixed old/new format in same file
3. Add test: fenced block in plain-text summary is NOT executed

### Step 4: Testing (js/*.test.js)

1. Unit tests for `formatFileHeader()`, `formatSessionGuide()`, `ensureFileHeader()`
2. Unit tests for updated `formatAgentHeader()`, `formatReplyHeader()`, `formatBackgroundEvent()`
3. Integration test: write reply to new file → verify header auto-added
4. Integration test: write reply to file with existing header → verify header unchanged
5. Integration test: mixed old/new format in same file → verify parsing works
6. Integration test: parse request with manual level-2 header + code block → verify code extracted
7. Edge case: truncation of 50 background events → verify ellipsis marker present

### Step 5: Manual Testing & Documentation

1. Start server (`npm start`)
2. Open live debugging session and create new REPL log (without manual header)
3. Run code block → verify level-1 header and guide auto-added
4. Add manual level-2 header for new debugging turn
5. Run more code → verify level-3 and level-4 headings generated
6. Verify outline navigation works in VS Code
7. Update `## Short Guide` section to mention version control before cleanup
8. Verify `README.md` and `docs/1-jsrepl.md` still describe format accurately (or update if needed)

## Considerations for AI Agents

The descriptive header at the top auto-teaches any LLM encountering this daebug REPL without any prior knowledge. Fewer confusion is expected, and better debugging performance.