# esbuild & Vite Plugin Architecture â€” Conceptual Plan

## Executive Summary

This document outlines a conceptual architecture for transforming ğŸ‘¾Daebug's standalone HTTP server into plugins/extensions for esbuild and Vite. The goal is to enable the same file-based REPL capabilities within existing development server workflows, allowing agents to interact with pages served by these popular build tools.

**Key Insight**: The core REPL logic (registry, job queue, parser, writer, file watcher) requires **no changes**. The challenge is purely integration: injecting client scripts into HTML responses and exposing the `/daebug` HTTP endpoint within each tool's runtime environment.

---

## Current Architecture Overview

### What Works Today

The standalone server (`js/server.js`) provides:

1. **Static file serving** with HTML injection (client script inserted before `</head>`)
2. **HTTP endpoints**: `/daebug` for polling (GET) and results (POST)
3. **File-based orchestration**: watches `debug/*.md` files, creates jobs, writes results
4. **Multi-realm support**: main pages and auto-spawned web workers

The client-side mechanism is self-contained:
- Polls `/daebug` endpoint for code to execute
- Executes in isolated async function context
- POSTs results back to server
- Manages worker lifecycle independently
- Includes test runner primitives as globals

File-based protocol is tool-agnostic:
- Append-only Markdown conversation format
- Debounced file watching detects new requests
- Server-written replies appear below requests
- Master registry tracks all active realms

### What Remains Unchanged

The following modules are **tool-agnostic** and require no modification:

- `registry.js`: Page lifecycle management, master `debug.md` updates
- `job.js`: Job queue and state machine
- `parser.js`: Request extraction from Markdown files
- `writer.js`: Result formatting and file writing
- `watcher.js`: File system watching with debouncing
- `client.js`: Browser-side polling/execution script
- `worker.js`: Web worker bootstrap script
- `test-runner.js`: Test primitives injection

These modules operate purely on Node.js APIs (fs, path) and have no knowledge of HTTP server implementation. They form the **Core Layer**.

---

## Plugin Architecture: Core/Adapter Pattern

### Conceptual Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         User's Build Tool               â”‚
â”‚    (esbuild serve / Vite dev server)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ Plugin API
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Adapter Layer                    â”‚
â”‚  (esbuild-plugin.js / vite-plugin.js)   â”‚
â”‚                                          â”‚
â”‚  Responsibilities:                       â”‚
â”‚  â€¢ Inject client script into HTML       â”‚
â”‚  â€¢ Expose /daebug HTTP endpoint          â”‚
â”‚  â€¢ Initialize core on startup            â”‚
â”‚  â€¢ Clean up on shutdown                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ Direct imports
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Core Layer                      â”‚
â”‚  (registry, job, parser, writer,        â”‚
â”‚   watcher, client, worker, test-runner) â”‚
â”‚                                          â”‚
â”‚  Responsibilities:                       â”‚
â”‚  â€¢ File watching and parsing             â”‚
â”‚  â€¢ Job queue management                  â”‚
â”‚  â€¢ Result writing                        â”‚
â”‚  â€¢ Client script generation              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The **Adapter Layer** is a thin shim that maps build-tool-specific APIs onto the tool-agnostic Core Layer. Each build tool gets its own adapter module implementing three critical functions:

1. **HTML Injection**: Insert client script into every HTML response
2. **Endpoint Exposure**: Handle GET/POST requests at `/daebug` path
3. **Lifecycle Management**: Initialize core on plugin load, clean up on exit

---

## Challenge 1: HTML Injection

### The Problem

Client script must be injected into every HTML document served by the dev server. The standalone server achieves this via string replacement (`readFileSync` â†’ `.replace('</head>', ...)` â†’ `res.end()`). Build tools have varying capabilities for HTML manipulation.

### Conceptual Solutions by Tool

#### Vite: transformIndexHtml Hook

Vite provides a **first-class HTML transformation API** designed exactly for this use case.

**Approach**:
- Use `transformIndexHtml` hook in plugin
- Return object with `{ tag: 'script', children: clientScript, injectTo: 'head-prepend' }`
- Vite handles insertion, escaping, and multiple entry points automatically

**Advantages**:
- Clean, declarative API
- Vite handles complex scenarios (nested HTML, multiple entries, virtual modules)
- Integrates with HMR naturally

**Considerations**:
- Hook runs during dev server transform pipeline, not at raw file level
- Need to verify behavior with SSR/SPA modes
- May need different injection point (`head-prepend` vs `body-end`) for script timing

**Fallback Strategy**:
If `transformIndexHtml` proves insufficient (edge cases with non-standard HTML processing):
- Use `transform` hook with file extension check
- Manually inject via regex/string manipulation
- Less elegant but functionally equivalent to standalone server

#### esbuild: Custom HTML Loader

esbuild has **no built-in HTML transformation system**. HTML files can be imported as text or URL, but there's no standard "transform HTML response" hook.

**Approach Options**:

1. **Plugin with onLoad for .html files**:
   - Register namespace or filter for `.html` files
   - Read file contents
   - Inject script via string manipulation
   - Return modified contents with loader: 'text' or 'file'
   - This works for bundled HTML but may not affect serve responses

2. **Plugin with onRequest in serve API**:
   - If user runs `esbuild.serve()`, intercept HTML requests
   - Modify response before sending to client
   - Requires serve API usage (not applicable for pure build mode)

3. **External transformation**:
   - Run post-build script that modifies HTML in outdir
   - Inject script into all .html files after build completes
   - Simple but doesn't work for watch mode or dev server

**Recommended Approach for esbuild**:
- Combine plugin `onLoad` (for bundled HTML) with documentation recommending `esbuild.serve()` + `onRequest` interception for dev workflow
- Acknowledge limitation: users not using serve API would need to manually include ğŸ‘¾Daebug script in HTML or use external tool

**Considerations**:
- esbuild's HTML support is minimal by design (not a primary use case)
- Many esbuild users don't serve HTML (library bundling, API servers)
- Plugin should gracefully handle absence of HTML files

#### Multi-Entry and SPA Scenarios

Both tools may serve multiple HTML files or use client-side routing with single HTML entry.

**Conceptual Solution**:
- Inject script into **every** HTML file that passes through the transform pipeline
- Client script self-registers with unique name (already implemented via `sessionStorage`)
- Multiple pages â†’ multiple entries in `debug.md` registry (already supported)
- SPA with one HTML â†’ one page entry, navigation doesn't create new realms (correct behavior)

**Edge Case**:
If user has 50 HTML files, do we inject into all? Yes. Each may become an active page. Registry culling (future enhancement) could remove stale entries.

---

## Challenge 2: HTTP Endpoint Exposure

### The Problem

Client script polls `/daebug?name=<page>&url=<url>` for code and POSTs results to same path. The endpoint must:
- Accept GET requests: query page registry, retrieve pending job, return code
- Accept POST requests: receive result payload, write to file, finish job
- Be available on the same origin as the page (to avoid CORS)

### Conceptual Solutions by Tool

#### Vite: configureServer Middleware

Vite's dev server is built on **Connect** (Express-compatible middleware system).

**Approach**:
- Use `configureServer` hook in plugin
- Add middleware with `server.middlewares.use('/daebug', handler)`
- Handler is standard Express-style `(req, res, next) => {}`
- Import and invoke existing `handlePoll` and `handleResult` logic from core

**Implementation Shape** (conceptual):
```
configureServer(server) {
  // Initialize core
  registry.init(root);
  
  server.middlewares.use('/daebug', (req, res) => {
    const url = new URL(req.url, 'http://localhost');
    
    if (req.method === 'GET') {
      // Call handlePoll logic from core
      const name = url.searchParams.get('name');
      const page = registry.getOrCreate(root, name, url.searchParams.get('url'));
      watcher.watchPage(root, page);
      const j = job.get(page.name);
      // ... respond with code or empty
    }
    
    if (req.method === 'POST') {
      // Collect body, parse, call handleResult logic
      // ... write result, finish job
    }
  });
}
```

**Advantages**:
- Native Vite API
- Full control over request/response
- Can reuse existing core logic with minimal wrapping

**Considerations**:
- Need to handle body parsing (Vite may or may not pre-parse)
- Need to set correct `Content-Type` headers
- Should add middleware early in chain (before user middleware)

#### esbuild: Serve API onRequest or Separate Server

esbuild has two modes:

1. **serve API** (`esbuild.serve()`): Runs lightweight HTTP server for development
2. **build/watch API**: Bundles files to disk without serving

**Approach 1: onRequest Interception (serve API only)**:
- When using `esbuild.serve({ onRequest: handler })`
- Handler receives `{ method, path }` and can modify response
- Check if path starts with `/daebug`, handle accordingly
- Return custom response bypassing esbuild's default handler

**Approach 2: External HTTP Server**:
- If user is not using serve API (or onRequest is insufficient)
- Run tiny standalone HTTP server on a different port (e.g., 8301)
- Client script polls `http://localhost:8301/daebug` instead of same-origin
- Requires CORS headers on responses

**Approach 3: Proxy Configuration**:
- User configures external proxy (nginx, etc.) to route `/daebug` to separate ğŸ‘¾Daebug server
- Plugin documentation describes setup
- Most flexible but requires user config

**Recommended Approach for esbuild**:
- **Primary**: Use `onRequest` if serve API is in use (detect during plugin setup)
- **Fallback**: Document that users should run a separate tiny server (provide script) and configure client to use cross-origin endpoint
- **Advanced**: Provide utility function to spawn background server automatically on different port

**Considerations**:
- esbuild's serve API is minimal (no middleware concept)
- `onRequest` is called for every request, even non-HTML (need efficient filtering)
- Many esbuild users don't use serve API at all (pure bundling workflow)

**Architectural Implication**:
For esbuild, may need **dual-mode plugin**:
- Mode A: Full integration (HTML injection + endpoint via serve API)
- Mode B: Endpoint-only (separate server, user manually includes script in HTML)

#### Protocol Considerations

If same-origin endpoint proves difficult in esbuild, consider **WebSocket** as alternative:
- Client opens WebSocket to separate server
- Bidirectional communication replaces GET polling + POST results
- Requires rewriting client polling loop but may be cleaner for esbuild case

**Trade-offs**:
- WebSocket is more complex (connection management, reconnection logic)
- Breaks from current HTTP polling simplicity
- Not explored in current design; should be considered if HTTP endpoint proves brittle

---

## Challenge 3: File Watching Integration

### The Problem

Core watcher (`watcher.js`) uses `fs.watch()` to detect changes in `debug/*.md` files. This must run independently of the build tool's own file watching system (which monitors source files for rebuilds).

### Conceptual Solution: Independent Watching

**Approach**:
- Adapter plugin initializes core watcher on startup
- Watcher runs in background, completely independent of esbuild/Vite watch systems
- No interaction between REPL file watching and source file watching

**Why This Works**:
- Build tools watch project sources (`.js`, `.ts`, etc.) for rebuild triggers
- ğŸ‘¾Daebug watches `debug/*.md` files for agent requests
- These are disjoint file sets â†’ no conflicts

**Implementation Shape** (conceptual):
```
// In plugin setup/configureServer:
registry.init(root);

// Watching happens lazily per page in watcher.watchPage()
// Called when page first polls /daebug endpoint
// No explicit watcher.start() needed
```

**Considerations**:
- `fs.watch()` is platform-dependent (use `chokidar` if instability occurs)
- Need to clean up watchers on plugin shutdown/rebuild
- Debouncing (150ms in current impl) prevents watch-loop thrashing

**Edge Case**:
If user modifies `debug/*.md` file in editor, build tool may also see change and trigger rebuild. This is harmless:
- Build tool rebuild is no-op (MD files not imported)
- ğŸ‘¾Daebug watcher detects change and creates job (correct)
- No double-triggering or race conditions

---

## Challenge 4: Plugin Lifecycle Management

### The Problem

Plugins must initialize core, start background processes, and clean up on exit. Build tools have different lifecycle hooks.

### Vite Lifecycle

**Hooks** (in order):
1. `config`: Early setup, can modify Vite config
2. `configResolved`: Final config available
3. `configureServer`: Dev server available (only in dev mode)
4. `buildStart`: Build begins (dev and prod)
5. `transformIndexHtml`: Per-HTML-file transform
6. `closeBundle`: Build ends
7. `buildEnd`: Final cleanup

**Recommended Usage**:
- `configResolved`: Initialize core (`registry.init(root)`)
- `configureServer`: Add `/daebug` middleware
- `transformIndexHtml`: Inject client script
- `buildEnd` or `closeBundle`: Cleanup (stop watchers)

**Considerations**:
- In dev mode, server runs indefinitely (no explicit end)
- In build mode, no server exists (skip endpoint setup)
- Need to detect mode and skip server-dependent features in build

### esbuild Lifecycle

**Hooks**:
1. `setup(build)`: Called once when plugin is added
2. `onStart`: Before each build
3. `onEnd`: After each build
4. `onLoad`, `onResolve`: Per-file during build

esbuild plugins are **build-scoped**, not server-scoped. Serve API is separate.

**Recommended Usage**:
- `setup`: Initialize core, register onLoad for HTML injection
- `onStart`: (optional) Refresh registry state
- `onEnd`: (optional) Update master registry
- Serve API: Configure separately in user's `esbuild.serve()` call

**Considerations**:
- Plugin has no direct access to serve instance
- User must configure serve API themselves and include ğŸ‘¾Daebug handler
- Documentation must explain two-part setup (plugin for injection, separate config for endpoint)

### Shutdown and Cleanup

**What Needs Cleanup**:
- File system watchers (`fs.watch()` instances)
- HTTP servers (if running separate server for esbuild)
- Pending job timers

**Approach**:
- Adapter plugin tracks cleanup tasks in closure
- On shutdown hook (`buildEnd` for Vite, `onEnd` for esbuild), invoke cleanup
- Core watcher should expose `watcher.stopAll()` utility (future enhancement)

**Edge Case**:
In watch mode (both tools), builds repeat indefinitely. Need to ensure cleanup only runs on true exit, not per-build-cycle end.

---

## Architectural Patterns and Principles

### Separation of Concerns

**Core Layer** (unchanged):
- Pure Node.js logic
- No knowledge of HTTP server implementation
- Exports functions that adapters can compose

**Adapter Layer** (tool-specific):
- Thin shim over core
- Maps tool APIs to core functions
- Handles tool-specific quirks

**Benefits**:
- Core can be tested independently
- New build tool support = new adapter, zero core changes
- Adapters can be maintained separately (different npm packages)

### Progressive Enhancement

**Philosophy**: ğŸ‘¾Daebug features should degrade gracefully if environment doesn't support them.

**Examples**:
- Workers fail to create (CSP violation) â†’ REPL continues in main thread only
- HTML injection fails (unusual esbuild setup) â†’ User manually includes script
- Endpoint unavailable (CORS, network) â†’ Clear error in browser console

**Implementation**:
- All feature initialization wrapped in try-catch
- Client script already handles worker failure gracefully
- Adapter should log warnings (not throw errors) on partial setup

### Configuration and Defaults

**Minimal Config Philosophy**: Plugin should work with zero configuration for common cases.

**Default Values**:
- Root directory: `process.cwd()` (or Vite's `root` config)
- Debug directory: `debug/` (relative to root)
- Endpoint path: `/daebug`
- Master file: `debug.md`
- Inject location: before `</head>` in HTML

**Configurable Options** (conceptual):
```
{
  root: '/path/to/project',
  debugDir: 'debug',
  endpoint: '/daebug',
  injectWorkers: true,
  injectTestRunner: true,
  customClientScript: (defaultScript) => defaultScript + extraCode
}
```

**User Override Use Cases**:
- Different endpoint path (avoid conflict with app routes)
- Disable workers (incompatible with user's CSP)
- Custom root (monorepo scenarios)

### Error Handling and Diagnostics

**Guiding Principle**: Failures should be visible but non-fatal. REPL is a debugging tool; it shouldn't break user's app.

**Error Categories**:

1. **Critical** (plugin should refuse to load):
   - Core module import failure (missing dependency)
   - Invalid configuration (root dir doesn't exist)

2. **Degraded** (log warning, continue):
   - HTML injection fails for some files
   - Worker creation fails
   - File watch fails on specific file

3. **Transient** (log debug, retry):
   - Network errors in client polling
   - File read errors (file deleted mid-watch)

**Logging Strategy**:
- Use build tool's logger if available (Vite's `logger`, esbuild's `console` wrapping)
- Prefix all logs with `[daebug]` for filterability
- Use log levels appropriately (error, warn, info, debug)

**User-Facing Errors**:
- Client script errors appear in browser console (already implemented)
- Server-side errors appear in terminal where dev server runs
- File-written errors appear in debug/*.md files (diagnostic blocks)

---

## Tool-Specific Considerations

### Vite Deep Dive

#### Advantages for Integration

- **Rich plugin API**: Many hooks for HTML, server, and lifecycle
- **Middleware system**: Native Express/Connect compatibility
- **HMR infrastructure**: Can leverage for future enhancements (live REPL state sync)
- **Large ecosystem**: Users expect plugins to "just work"

#### Potential Challenges

**HTML Processing in SSR Mode**:
- Vite's `transformIndexHtml` behaves differently in SSR vs SPA
- Need to verify injection works for server-rendered pages
- May need conditional logic based on `server.config.ssr`

**Virtual Modules**:
- Vite uses virtual modules extensively (e.g., `/@vite/client`)
- Client script injection should not interfere with Vite's own injected scripts
- Ensure injection point is after Vite's scripts (or use `enforce: 'post'`)

**Plugin Ordering**:
- Other plugins may also transform HTML (framework plugins, etc.)
- ğŸ‘¾Daebug plugin should probably run late (`enforce: 'post'`) to avoid conflicts
- But not so late that HTML is finalized and immutable

**Multiple Servers**:
- Vite can run multiple dev servers (SSR + client)
- Need to ensure ğŸ‘¾Daebug doesn't double-register or conflict between servers
- May need to detect server type and skip SSR server

#### Recommended Plugin Structure (Conceptual)

```
export default function daebugPlugin(options = {}) {
  const root = options.root || process.cwd();
  let server;
  
  return {
    name: 'daebug',
    enforce: 'post',
    
    configResolved(config) {
      // Initialize core
      registry.init(root);
    },
    
    configureServer(_server) {
      server = _server;
      
      // Add /daebug middleware
      server.middlewares.use('/daebug', (req, res) => {
        // ... handle GET/POST
      });
    },
    
    transformIndexHtml: {
      order: 'pre',
      handler(html, ctx) {
        return {
          html,
          tags: [{
            tag: 'script',
            children: clientScript,
            injectTo: 'head-prepend'
          }]
        };
      }
    },
    
    buildEnd() {
      // Cleanup watchers
    }
  };
}
```

### esbuild Deep Dive

#### Challenges for Integration

- **Minimal HTML support**: Not designed as full-featured web server
- **No middleware concept**: HTTP handling is basic
- **Build-focused**: Primary use case is bundling, not serving
- **Lower-level API**: More manual setup required

#### Potential Approaches

**Approach A: Tight Integration (serve API users)**:
- Plugin injects client script via `onLoad` for `.html` files
- Plugin returns setup instructions for `esbuild.serve()` config
- User adds `onRequest` handler that checks path and delegates to ğŸ‘¾Daebug

**Approach B: Loose Integration (all users)**:
- Plugin documentation explains manual script inclusion
- Separate tiny HTTP server provided (single-file, no dependencies)
- User runs server alongside esbuild build/watch
- Client script polls cross-origin (requires CORS headers)

**Approach C: Hybrid**:
- Plugin detects if serve API is in use (check `build.initialOptions`)
- If yes, use Approach A
- If no, log instructions for Approach B

**Recommended Path**: Start with Approach B (maximally compatible), offer Approach A as optional enhancement.

#### Plugin Shape (Conceptual)

```
export function daebugPlugin(options = {}) {
  const root = options.root || process.cwd();
  
  return {
    name: 'daebug',
    
    setup(build) {
      // Initialize core
      registry.init(root);
      
      // Inject client script into HTML files
      build.onLoad({ filter: /\.html$/ }, async (args) => {
        const source = await fs.promises.readFile(args.path, 'utf8');
        const injected = source.replace('</head>', `<script>${clientScript}</script></head>`);
        return { contents: injected, loader: 'text' };
      });
      
      // Log instructions for endpoint setup
      console.log('[daebug] Run separate server: node daebug-server.js');
      console.log('[daebug] Or configure esbuild.serve() with onRequest handler');
    }
  };
}
```

#### Separate Server for esbuild (Conceptual)

Provide a single-file HTTP server users can run:

```
// daebug-server.js (provided by plugin package)
import { createServer } from 'http';
import * as registry from 'daebug/core/registry';
import * as job from 'daebug/core/job';
import * as watcher from 'daebug/core/watcher';

const root = process.argv[2] || process.cwd();
const port = process.argv[3] || 8301;

registry.init(root);

createServer((req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*'); // CORS for cross-origin
  // ... handle /daebug GET/POST
}).listen(port);

console.log(`[daebug] Endpoint listening on http://localhost:${port}/daebug`);
```

User runs: `node daebug-server.js & esbuild --watch`

**Trade-offs**:
- Simple, explicit, debuggable
- Requires user to manage two processes
- CORS may have security implications (dev-only)

---

## Web Worker Considerations

### Current Implementation

Client script auto-creates web worker with same REPL capabilities:
- Worker polls separate `/daebug` endpoint with unique name (`page-name-webworker`)
- Worker has own `debug/*.md` file and registry entry
- Main thread monitors worker health and restarts on failure

### Challenges in Plugin Context

**CSP (Content Security Policy)**:
- Worker creation via blob URL may be blocked by CSP `worker-src` directive
- More common in production but can occur in dev
- Vite and esbuild don't typically set CSP in dev, but user's HTML might

**Module Workers**:
- Current worker uses classic script (`new Worker(blobURL)`)
- Module workers (`new Worker(url, { type: 'module' })`) are cleaner but less compatible
- esbuild/Vite may have opinions about worker bundling

**Worker Script Bundling**:
- Current approach: inline worker source as template literal in client script
- Alternative: Bundle worker separately, load via URL
- Vite has built-in worker bundling (`new Worker(new URL('./worker.js', import.meta.url))`)
- esbuild has no special worker handling

### Recommendations

**Short Term**: Keep current implementation (inline blob URL)
- Works in most dev environments
- No build tool integration needed
- Fails gracefully (logs warning, continues without worker)

**Long Term**: Explore build-tool-specific worker handling
- Vite: Use Vite's worker bundling for cleaner module handling
- esbuild: Continue with inline blob or provide separate worker bundle
- Make configurable (`injectWorkers: false` to disable)

**Documentation**:
- Explain CSP implications
- Show how to verify worker creation in DevTools
- Provide troubleshooting steps if workers fail

---

## Testing and Validation Strategy

### What Needs Testing

**Core Layer** (unchanged):
- Already has unit tests (`.test.js` files in `js/` dir)
- Parser, job queue, registry logic
- File watching and debouncing

**Adapter Layer** (new):
- HTML injection correctness
- Endpoint request handling
- Plugin lifecycle (init, shutdown)

**Integration** (end-to-end):
- Full flow: agent writes to MD file â†’ page executes â†’ result written back
- Multi-page scenarios
- Worker creation and failover
- Test runner execution

### Testing Approaches

**Unit Tests for Adapters**:
- Mock build tool APIs (Vite's `configureServer`, esbuild's `build.onLoad`)
- Verify injection produces correct HTML
- Verify endpoint handlers call core functions correctly

**Integration Tests**:
- Real esbuild/Vite instances
- Simple test project with HTML file
- Automated agent writes request to MD file
- Assert result appears in file within timeout
- Teardown and cleanup

**Manual Validation**:
- Create example projects using plugin
- Follow README instructions
- Verify REPL works in browser
- Test worker creation
- Test test runner API

### Continuous Integration

- Run unit tests on every commit
- Run integration tests on PR (slower, full stack)
- Test against multiple Vite versions (4.x, 5.x)
- Test against multiple esbuild versions (0.19.x, 0.20.x+)

---

## Documentation Strategy

### Conceptual Documentation Layers

**Layer 1: README** (for plugin users)
- Installation: `npm install daebug-vite-plugin` or `daebug-esbuild-plugin`
- Minimal config example
- How to verify it's working (check `debug.md`)
- Link to core ğŸ‘¾Daebug docs for REPL usage

**Layer 2: Plugin Configuration** (for customization)
- All config options with defaults
- Advanced scenarios (monorepo, custom paths)
- Troubleshooting common issues

**Layer 3: Architecture** (for contributors)
- This document (conceptual)
- Core/Adapter split explanation
- How to add support for new build tool

**Layer 4: API Reference** (for programmatic usage)
- Exported functions from core
- Adapter plugin API surface
- TypeScript definitions

### Key Documentation Challenges

**User Mental Model**:
- Users familiar with Vite/esbuild may not understand REPL concept
- Need clear "what is this?" section
- Show concrete example (agent writes code â†’ page runs it â†’ result appears)

**Setup Differences**:
- Vite plugin is simpler (one-step install)
- esbuild plugin may require two-step setup (plugin + endpoint)
- Documentation must explain why without overwhelming user

**Troubleshooting**:
- Common issues: CSP blocking, file permissions, port conflicts
- Provide diagnostic commands (check if endpoint responds, check worker in DevTools)
- Explain log output

---

## Future Enhancements (Out of Scope)

### WebSocket Protocol

Replace HTTP polling with WebSocket for lower latency and better multiplexing.

**Benefits**:
- Bidirectional communication without polling overhead
- Server can push jobs immediately (no 500ms delay)
- Better for high-frequency REPL usage

**Challenges**:
- More complex client logic (connection management, reconnection)
- Requires WebSocket server in adapter (not all build tools support natively)
- Harder to debug (can't inspect with curl/browser network tab as easily)

### Live REPL State Sync

Leverage HMR infrastructure to sync REPL state across page reloads.

**Vision**:
- Agent defines persistent variables/functions
- HMR preserves them across code changes
- Faster iteration (no re-initialization after edit)

**Challenges**:
- HMR is source-code-focused, not REPL-focused
- State serialization complexity
- Tool-specific HMR APIs (Vite vs esbuild differ)

### Multi-Server Coordination

In complex setups (SSR, microservices), coordinate multiple ğŸ‘¾Daebug instances.

**Vision**:
- Single `debug.md` registry for all services
- Agent can target different backend services
- Unified REPL across distributed system

**Challenges**:
- Requires inter-process communication
- Complex coordination logic
- Out of scope for initial plugin release

---

## Migration Path

### From Standalone Server to Plugin

**User Perspective**:
- Currently: Run `node js/cli.js` to start ğŸ‘¾Daebug server
- With plugin: Add plugin to Vite/esbuild config, use existing dev server

**Migration Steps**:
1. Install plugin package
2. Add to config file
3. Stop standalone server
4. Restart dev server
5. Verify `/daebug` endpoint responds
6. Continue using `debug/*.md` files as before

**Backward Compatibility**:
- Standalone server remains available for users not using Vite/esbuild
- Core modules unchanged â†’ same file format, same behavior
- Existing `debug/*.md` files work with plugin (no migration needed)

### Plugin Versioning Strategy

- Core and adapters versioned together initially (monorepo)
- Later: Separate packages with peer dependencies
- Example: `daebug-core@1.0.0`, `daebug-vite-plugin@1.0.0` (depends on `daebug-core@^1.0.0`)

---

## Open Questions and Decisions Deferred

These are intentionally left unresolved, to be addressed during implementation:

1. **Exact HTML injection point**: `head-prepend`, `head-end`, or `body-end`?
   - Depends on timing requirements and user script expectations
   - Test empirically

2. **esbuild endpoint strategy**: Separate server vs onRequest hook?
   - Depends on user feedback about setup complexity
   - May offer both options

3. **Worker bundling approach**: Inline blob vs Vite worker bundling?
   - Depends on Vite API stability and CSP prevalence
   - Start with blob, migrate if needed

4. **Config surface area**: How many options to expose?
   - Start minimal, expand based on user requests
   - Avoid premature configuration

5. **TypeScript support**: Should adapters be written in TS?
   - Core is JS with JSDoc types (good enough)
   - Adapters could be TS for better DX
   - Decision per-adapter based on ecosystem norms

6. **Error reporting format**: How to surface errors to agent?
   - Current: Plain text in MD file
   - Alternative: Structured JSON for programmatic parsing
   - Depends on agent capabilities

---

## Conclusion

The transformation of ğŸ‘¾Daebug from standalone server to plugin/extension for esbuild and Vite is **architecturally straightforward**: the core logic requires no changes. The challenge is purely integration, mapping each build tool's specific APIs onto the tool-agnostic core.

**Key Insights**:

1. **Core/Adapter split** enables clean separation and reusability
2. **HTML injection** is well-supported in Vite, requires workarounds in esbuild
3. **Endpoint exposure** is native in Vite, may need separate server for esbuild
4. **File watching** is independent and works identically in both tools
5. **Worker and test runner** features carry over unchanged

**Next Steps** (for implementation phase):

1. Refactor existing `server.js` to extract core logic into reusable functions
2. Implement Vite adapter plugin (cleaner API, faster validation)
3. Implement esbuild adapter plugin (document limitations upfront)
4. Write integration tests for both
5. Publish as separate npm packages with unified documentation

**Design Philosophy Summary**:

This plan is intentionally **conceptual and architectural**. It does not prescribe specific files, exact code snippets, or detailed implementation steps. Those decisions are best made during implementation when real-world constraints and build tool APIs can be tested empirically. The goal here is to establish the **mental model** and **integration patterns** that guide future work.
