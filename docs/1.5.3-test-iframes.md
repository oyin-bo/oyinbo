# Recent Improvements — November 2025

This document summarizes the recent architectural and implementation improvements to daebug, organized by three major themes: failure resilience, test isolation, and timestamp coherence.

---

## 1. Internal Refactoring: Failure Resilience in Multiple Phases

### Overview

The test runner now implements multi-phase failure handling to ensure robust recovery from errors at different stages of test execution: during test discovery, test setup/teardown, individual test runs, and result reporting.

### Key Changes

**Scope:** Primarily `js/modules/node-test.js`

#### Phase-Based Error Handling

Each major test execution phase now has explicit error capture and recovery:

1. **Discovery Phase** — File globbing and test file loading
   - Errors in pattern matching or file I/O are caught and reported separately
   - Prevents one broken test file from blocking discovery of others

2. **Import/Setup Phase** — Dynamic imports and test registration
   - Import errors are captured with full stack traces
   - Test registry is isolated per realm (main thread vs. worker vs. iframe)
   - Allows subsequent tests to load even if one import fails

3. **Execution Phase** — Individual test runs
   - Each test is wrapped with its own timeout handler
   - Test-level errors (assertions, unhandled promises) don't corrupt overall progress
   - Failed tests generate structured error objects with message and stack

4. **Streaming/Reporting Phase** — Progress updates and final results
   - Background events are independently captured and flushed
   - Failures in streaming don't prevent result finalization
   - Multiple error arrays (`errors` vs. `backgroundEvents`) separate concerns

#### Realm-Aware Test Registry

```javascript
function getTestRegistry(realmId) {
  const g = globalThis;
  if (!g.__daebug_test_registries) g.__daebug_test_registries = {};
  if (!g.__daebug_test_registries[realmId]) g.__daebug_test_registries[realmId] = {
    tests: [], currentSuite: null
  };
  return g.__daebug_test_registries[realmId];
}
```

- **Main realm** (page thread): `realmId = 'main'` (from sessionStorage)
- **Worker realm**: `realmId = worker.name` (extracted from `self.name`)
- **Unknown realm**: `realmId = 'unknown'` (fallback)

This isolation prevents test registry corruption when tests run concurrently in different execution contexts.

#### Structured Error Result Objects

When tests fail, results now include:

```javascript
{
  ok: false,
  error: <error message string>,
  errors: [<additional error details>],
  backgroundEvents: [<console/crash events during execution>],
  value: undefined
}
```

The separation of `error` (primary), `errors` (supplementary), and `backgroundEvents` (environmental) allows consumers to distinguish between test failures, framework errors, and unexpected side effects.

### Benefits

- **Isolation:** Failure in one phase doesn't cascade to later phases
- **Diagnostics:** Error context is preserved across boundaries (realm, execution environment)
- **Recovery:** Streaming continues even if background event flush fails; results are still recorded
- **Visibility:** Multiple error arrays provide granular insight into what went wrong

---

## 2. Test Execution Migration: IFRAME Scopes for Isolation

### Overview

In-page test execution has been migrated from direct DOM injection to an isolated IFRAME scope. This provides process-like isolation while maintaining access to import maps and page context.

### Key Changes

**Scope:** `js/modules/node-test.js` — new functions: `createTestIframe()`, `runTestsInPageRealm()`, `destroyTestIframe()`

#### IFRAME Creation & Import Map Extraction

```javascript
async function createTestIframe(options) {
  // Extract import maps from parent document
  const importMaps = extractImportMaps(document);
  
  // Create isolated iframe
  const iframe = document.createElement('iframe');
  iframe.id = 'daebug-test-iframe-' + Date.now();
  iframe.style.display = 'none';
  
  // Inject Node.js shim (global, process, setImmediate, Buffer)
  // Inject import maps
  // Return promise resolving when iframe ready
}
```

**Import Map Inheritance:** Child iframe inherits all `<script type="importmap">` elements from the parent, ensuring that test code can use the same module resolution as the page.

#### Node.js Shim

Tests run in browsers expect Node.js globals. A lightweight shim provides:

- `global` → `window`
- `process` → minimal object with `env`, `argv`, `nextTick`
- `setImmediate` / `clearImmediate` → polyfill via `setTimeout`
- `Buffer` → stub (prevents `ReferenceError` without full binary support)

This allows browser-based tests to use `import { test } from 'node:test'` and `import assert from 'node:assert'` seamlessly.

#### Bridge for Result Communication

Results from iframe test execution are communicated back to the main thread via the IFRAME's message bridge:

```javascript
// In iframe scope:
self.postMessage({ type: 'test-result', payload: { ok, error, backgroundEvents } });

// In main thread:
iframe.contentWindow.postMessage({ type: 'execute-tests', code }, '*');
iframe.addEventListener('message', e => {
  if (e.data?.type === 'test-result') {
    // Handle result
  }
});
```

#### Resource Cleanup

After test completion, the iframe is destroyed:

```javascript
function destroyTestIframe(iframe) {
  try { iframe.contentWindow?.close?.(); } catch {}
  iframe.remove();
}
```

This ensures that DOM resources, event listeners, and timers in the test context don't leak into the main page.

### Benefits

- **Isolation:** Each test run has its own DOM, window object, and event loop (within limits of iframe model)
- **Cleanliness:** Failed tests can't modify page state; next test runs in a fresh environment
- **Observability:** Background events (console, errors) are captured in the isolated scope and reported
- **Safety:** Infinite loops or blocking code in one test doesn't freeze the main page thread

---

## 3. Timestamp Coherence: ISO Strings Across All Messages

### Overview

All timestamp fields in transported messages have been standardized to ISO 8601 string format (`"2025-11-08T12:34:56.789Z"`). Presentation formatting (human-readable HH:MM:SS) is applied only at render time.

### Canonical Message Timestamps

| Message kind | Field name | Type | Purpose |
|---|---|---|---|
| Per-test item | `completedAt` | ISO string | When individual test finished |
| Progress / streaming update | `reportedAt` | ISO string | When progress was emitted |
| Final test results | `reportedAt` | ISO string | When final summary was emitted |
| Background / console event | `eventAt` | ISO string | When event occurred in realm |
| Background flush | `reportedAt` | ISO string | When flush was sent to server |
| Job request | `requestedAt` | ISO string | When job was created |
| Job result / reply | `reportedAt` | ISO string | When result was posted |
| Worker heartbeat | `pingAt` or `reportedAt` | ISO string | When ping/pong sent |

### Implementation Details

#### 1) Job Creation Timestamp (`requestedAt`)

**File:** `js/job.js`

```javascript
export function create(page, agent, code, requestHasFooter = true) {
  const job = {
    // ... other fields ...
    requestedAt: new Date().toISOString(),  // ISO string, not numeric ms
    startedAt: null,
    finishedAt: null
  };
  // ...
}
```

**Consumer:** `js/writer.js` formats `requestedAt` via `formatAgentHeader(agent, target, requestedAt)` for display in markdown.

#### 2) Test Completion Timestamps (`completedAt`)

**File:** `js/modules/node-test.js`

Each test result includes:

```javascript
{
  name: string,
  suite?: string,
  passed?: boolean,
  skipped?: boolean,
  error?: string,
  duration: number,              // milliseconds (numeric)
  completedAt: string            // ISO timestamp
}
```

When test finishes:
```javascript
const completedIso = new Date().toISOString();
testResult.completedAt = completedIso;
```

**Consumer:** `js/test.template.js` parses and displays:

```javascript
const ts = test.fullTs || (test.completedAt ? clockFmt(test.completedAt) : '');
// Renders as: HH:MM:SS format in markdown
```

#### 3) Progress Report Timestamps (`reportedAt`)

**File:** `js/modules/node-test.js`

Progress updates include top-level `reportedAt`:

```javascript
await streamProgress({
  complete: false,
  reportedAt: new Date().toISOString(),  // When this update was sent
  recentTests: [...],
  allTests: [...],
  totals: { pass, fail, skip, total },
  duration: ms
});
```

Final progress includes `reportedAt` indicating completion time:

```javascript
await streamProgress({
  complete: true,
  reportedAt: new Date().toISOString(),  // When final summary emitted
  allTests: [...],
  totals: { ... }
});
```

#### 4) Background Event Timestamps (`eventAt`)

**Files:** `js/client.js`, `js/modules/worker-bootstrap.js`

Each background event (console, error, unhandled rejection) includes `eventAt`:

```javascript
backgroundEvents.push({
  type: 'error' | 'console',
  source?: 'window.onerror' | 'unhandledrejection',
  level?: string,
  eventAt: new Date().toISOString(),      // When event occurred
  message: string,
  stack?: string
});
```

No human-formatted fields (`fullTimestamp`, `caller`) are included in transported events — only the ISO timestamp and message.

**Consumer:** `js/repl.template.js` formats for display:

```javascript
export function clockFmt(iso) {
  const when = Date.parse(iso);
  const d = new Date(when);
  return [d.getHours(), d.getMinutes(), d.getSeconds()]
    .map(x => String(x).padStart(2, '0'))
    .join(':');
}
```

#### 5) Background Flush Timestamp (`reportedAt`)

When client has accumulated background events, it sends a flush with top-level `reportedAt`:

```javascript
await fetch(endpoint, {
  method: 'POST',
  body: JSON.stringify({
    reportedAt: new Date().toISOString(),  // When flush sent
    events: backgroundEvents,               // Each event has eventAt
    jobId: ...
  })
});
```

#### 6) Worker Heartbeat Timestamps

**File:** `js/modules/worker-bootstrap.js`

Worker pong response includes timestamp:

```javascript
self.addEventListener('message', e => {
  if (e.data?.type === 'ping') {
    self.postMessage({ 
      type: 'pong', 
      timestamp: new Date().toISOString()  // ISO ping timestamp
    });
  }
});
```

### Formatting Rules (Global)

1. **Transported messages:** Always use ISO strings for any timestamp field
2. **Duration fields:** Remain numeric (milliseconds) for arithmetic
3. **Presentation (markdown):** Apply `clockFmt(iso)` to produce HH:MM:SS for human display
4. **No preformatted strings in transport:** Remove `fullTimestamp`, `caller`, or any human string from event objects

### Benefits

- **Consistency:** All code paths use same timestamp format; no surprises
- **Machine-readability:** ISO strings parse reliably with `Date.parse()` or `new Date(string)`
- **Arithmetic:** Easier to compute time deltas: `new Date(iso1) - new Date(iso2)`
- **Auditability:** Timestamps can be logged, indexed, and compared without conversion
- **Separation of concerns:** Transport layer (ISO) separate from presentation layer (HH:MM:SS formatting)

---

## Architecture Summary

The three improvements work together to create a more robust, isolated, and introspectable testing system:

1. **Multi-phase failure handling** ensures each phase (discovery, setup, execution, reporting) can fail independently without cascading
2. **IFRAME isolation** provides clean, repeatable test execution environments without affecting the main page
3. **ISO timestamp coherence** unifies all message formats and enables better time-based debugging and log analysis

---

## Testing & Verification

Key areas to verify these improvements:

1. **Multi-phase resilience:**
   - Run tests with bad imports — should report discovery error without blocking entire run
   - Run tests with failing assertions — progress should continue, final results recorded
   - Kill a worker mid-test — main realm should continue executing

2. **IFRAME isolation:**
   - Modify DOM in test — iframe destroyed, page DOM unchanged
   - Run two tests in sequence — each starts in fresh iframe with no state carryover
   - Generate errors in test — errors captured in iframe, not logged to main console twice

3. **Timestamp coherence:**
   - Inspect network requests to `/-daebug-test-progress` — all timestamps are ISO strings
   - Check markdown output — times render as HH:MM:SS, not raw ISO
   - Verify `job.requestedAt`, `test.completedAt`, `event.eventAt` are ISO in JSON payloads

---

## Files Modified

**Core:** `js/modules/node-test.js`, `js/job.js`

**Event capture:** `js/client.js`, `js/modules/worker-bootstrap.js`

**Reporting:** `js/writer.js`, `js/test.template.js`, `js/repl.template.js`

**Referenced plan:** `docs/timestamps-refactor-plan.md` (detailed per-case guide)

---

*Summary compiled November 8, 2025*
